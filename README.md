**Документация проекта:**

Для запуска введите:

`docker-compose build serverService clientService1 clientService2 clientService3 clientService4`

`docker-compose up serverService clientService1 clientService2 clientService3 clientService4`

Через 5 секунд (константа прописана в файле server.py) после запуска сервера он раз в секунду будет проверять, достаточно ли людей для начала игры и пытаться начать игру. После завершения предыдущей игры все подключенные юзеры будут добавлены в новую игру и через те же пять секунд сервер опять будет пытаться начать игру. 5 секунд нужны для того, чтобы можно было успеть остановить контейнеры между играми (иначе они просто очень быстро играют очень много игр подряд), и для того, чтобы к первой игре успели подключиться все игроки, которые хотят.

И 4 клиента начнут играть в мафию друг с другом, пока игра не завершится.

**Структура проекта**

У клиента и у сервера есть по grpc-серверу. Сервер клиента однопоточный, сервер сервера многопоточный. Сервер клиента поддерживает список игроков, подключённых к серверу, для этого у него вызываются методы NotifyLeave и NotifyJoin. Раз в секунду вызывается метод Ping для проверки того, не отключился ли пользователь. Внутриигровые уведомления отсылаются при помощи метода GameNotify, а при помощи специального метода GiveActionOptions пользователю присылаются действия, которые он должен выполнить. После этого пользователь может потратить сколько угодно времени на то, чтобы прислать ответ (но в реализации ботов они присылают ответ даже до того, как отвечают на GiveActionOptions, чтобы не нарушать их однопоточность).

Файл mafia.py отвечает за всю логику игры и предоставление уведомлений, которые нужно рассылать игрокам. Для уведомлений есть методы take_notification и take_await_actions, которые нужны для того, чтобы сервер рассылал уведомления и опрашивал игроков об их дальнейших действиях.

Логика игры описывается условием задачи. Все действия описываются некоторым голосованием, а именно, мафия голосует за то, кого убить, полицейские голосуют за то, кого проверить, днём все голосуют за то, кого повесить. Игрок может вызвать метод Sleep днём и заснуть (до голосования, в таком случае он его пропускает, или после голосования), или аналогичный метод Wake ночью. Игрок может несколько раз звать метод Vote/Kill/Check, будет считаться, что игрок изменил решение и переголосовал.  Все голосования различаются перед началом следующего времени суток (то есть днём - когда все лягут спать, ночью - когда все проснутся), затем начинается новое время суток, всем приходит соответствующее уведомление и все начинают предпринимать свои внутриигровые действия.

**Безопасность**
Каждый игрок "авторизуется" своим адресом. Для того чтобы делать действия, он должен указывать свой адрес. Каждый игрок видит имена всех игроков, но не адреса, поэтому это "безопасно". Действие, присланное игроком, проверяется на то, разрешено ли оно (боты всегда выполняют только разрешённые действия). Если оно не разрешено, в ответ на действие присылается специальное сообщение с соответствующим кодом (`messages.ActionResult.Status.NotAllowed`). Если игрок перестаёт отвечать на пинги, он отключается и всем игрокам приходит об этом уведомление.

У класса Server и класса GameState есть мьютексы, которыми они защищаются от Race Condition.